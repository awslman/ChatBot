package IntentRecognizer;import edu.stanford.nlp.pipeline.*;import edu.stanford.nlp.ling.*;import edu.stanford.nlp.sentiment.SentimentCoreAnnotations;import edu.stanford.nlp.neural.rnn.RNNCoreAnnotations;import edu.stanford.nlp.trees.*;import edu.stanford.nlp.util.*;import java.util.*;import java.util.regex.Pattern;/** * Stanford CoreNLP 意图识别器 * <p> * 该类使用 Stanford CoreNLP 工具包进行自然语言处理，并基于多种特征（如情感、语法结构、命名实体和关键词）来识别用户输入文本的意图类型。支持的意图包括问候、告别、提问、抱怨等常见交互场景。</p> */public class IntentRecognizer_StanfordCoreNLP extends IntentRecognizer {    private StanfordCoreNLP pipeline;   // 管道处理：StanfordCoreNLP 管道分析    private Properties props;           // 初始化配置：Properties 设置注解器,相当于配置文件//  构造函数：初始化 Stanford CoreNLP 流水线并加载相关模型配置    public IntentRecognizer_StanfordCoreNLP() {        initializePipeline();    }    /**     * 初始化 NLP 处理流水线，设置所需的注解器及参数     * <p>使用的注解器包括分词、句子分割、词性标注、词形还原、依存句法分析、情感分析和命名实体识别</p>     */    private void initializePipeline() {        props = new Properties();        // 使用全面的分析器        /*  annotators：定义了需要使用的注解器序列，按顺序执行：            tokenize：分词器，将文本分割成单词和标点符号            ssplit：句子分割器，将文本分割成句子            pos：词性标注器，为每个词标注词性（名词、动词等）            lemma：词形还原器，将词还原为其基本形式            parse：句法分析器，分析句子的语法结构            sentiment：情感分析器，判断句子的情感倾向            ner：命名实体识别器，识别人名、地名、组织名等实体            coref.algorithm , neural：设置共指消解算法为神经网络算法            ner.useSUTime：禁用时间表达式识别功能        */        props.setProperty("annotators", "tokenize, ssplit, pos, lemma, parse, sentiment, ner");        props.setProperty("coref.algorithm", "neural");        props.setProperty("ner.useSUTime", "false");        try {            this.pipeline = new StanfordCoreNLP(props);        } catch (Exception e) {            System.err.println("Stanford CoreNLP 初始化失败: " + e.getMessage());        }    }    /**     * 对给定文本执行意图识别任务，综合多个维度的信息计算最可能的意图类别及其置信度     *     * @param text 用户输入的原始文本字符串     * @return 返回一个包含识别出的主要意图、置信度以及解释说明的结果对象 {@link IntentAnalysisResult}     */    public IntentAnalysisResult recognizeIntent(String text) {        if (pipeline == null) {            return new IntentAnalysisResult(Intent.UNKNOWN, 0.0, "Pipeline not initialized");        }//        创建 Annotation 对象：包装待处理的原始文本        Annotation document = new Annotation(text);//        执行 annotate() 方法：按配置的注解器顺序对文本进行逐层分析        pipeline.annotate(document);        Map<String, Double> intentScores = new HashMap<>();        // 分析每个句子，并累计得分        for (CoreMap sentence : document.get(CoreAnnotations.SentencesAnnotation.class)) {            analyzeSentence(sentence, intentScores);        }        // 根据累计的意图得分确定最主要的意图类别，并计算置信度        Intent primaryIntent = determinePrimaryIntent(intentScores);        double confidence = calculateConfidence(intentScores, primaryIntent);        return new IntentAnalysisResult(primaryIntent, confidence, generateExplanation(intentScores));    }    /**     * 针对单个句子从不同角度进行意图评分分析     *     * @param sentence 当前要分析的句子对象     * @param intentScores 存储各意图得分的映射表     */    private void analyzeSentence(CoreMap sentence, Map<String, Double> intentScores) {        // 1. 情感分析        analyzeSentiment(sentence, intentScores);        // 2. 句法结构分析        analyzeSyntax(sentence, intentScores);        // 3. 命名实体分析        analyzeEntities(sentence, intentScores);        // 4. 关键词模式匹配        analyzeKeywords(sentence, intentScores);    }    /**     * 利用情感树预测当前句子的情感倾向，并据此调整对应意图的分数     *     * @param sentence 当前句子对象     * @param intentScores 各意图得分记录     */    private void analyzeSentiment(CoreMap sentence, Map<String, Double> intentScores) {        try {//            从句子中获取情感分析树，该树包含了句子的情感信息            Tree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);//            从情感树中提取预测的情感类别（0-4，分别代表非常负面到非常正面）            int sentiment = RNNCoreAnnotations.getPredictedClass(tree);            switch (sentiment) {                case 0: // 非常负面                    intentScores.merge("COMPLAINT", 0.8, Double::sum);                    break;                case 1: // 负面                    intentScores.merge("COMPLAINT", 0.5, Double::sum);                    break;                case 3: // 正面                    intentScores.merge("COMPLIMENT", 0.5, Double::sum);                    break;                case 4: // 非常正面                    intentScores.merge("COMPLIMENT", 0.8, Double::sum);                    break;            }        } catch (Exception e) {            // 忽略情感分析异常        }    }    /**     * 分析句子的句法结构以判断是否属于疑问句或祈使句，并结合标点符号进一步增强意图判断能力     *     * @param sentence 当前句子对象     * @param intentScores 各意图得分记录     */    private void analyzeSyntax(CoreMap sentence, Map<String, Double> intentScores) {        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);        if (tree != null) {            String treeString = tree.toString();            // 检测疑问句结构：SQ表示疑问句的倒装结构，SBARQ表示疑问词引导的从句结构            // 如果句子包含这些语法结构，则认为很可能是问题，增加QUESTION意图的得分            if (treeString.contains("SQ") || treeString.contains("SBARQ")) {                intentScores.merge("QUESTION", 0.7, Double::sum);            }            // 祈使句检测（请求）            if (treeString.contains("VP") && treeString.contains("VB") && !treeString.contains("NP")) {                intentScores.merge("REQUEST_HELP", 0.6, Double::sum);            }        }        // 标点符号分析        String text = sentence.toString();        if (text.contains("?")) {            intentScores.merge("QUESTION", 0.3, Double::sum);        }        if (text.contains("!")) {            intentScores.merge("EMERGENCY", 0.4, Double::sum);        }    }    /**     * 解析句子中的命名实体标签，根据识别到的人名、地名或机构名称推断潜在意图方向     *     * @param sentence 当前句子对象     * @param intentScores 各意图得分记录     */    private void analyzeEntities(CoreMap sentence, Map<String, Double> intentScores) {        List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);        for (CoreLabel token : tokens) {            String ner = token.get(CoreAnnotations.NamedEntityTagAnnotation.class);            if ("PERSON".equals(ner)) {                // 识别出人名，可能是问候，为GREETING方向加分                intentScores.merge("GREETING", 0.3, Double::sum);            } else if ("LOCATION".equals(ner) || "ORGANIZATION".equals(ner)) {                // 识别出地点或组织，可能是要请求信息                intentScores.merge("REQUEST_INFO", 0.4, Double::sum);            }        }    }    /**     * 扫描句子中是否存在特定意图相关的关键词组合，并据此提升相应意图的权重     *     * @param sentence 当前句子对象     * @param intentScores 各意图得分记录     */    private void analyzeKeywords(CoreMap sentence, Map<String, Double> intentScores) {        String text = sentence.toString().toLowerCase();        // 问候关键词        if (Pattern.compile("\\b(hello|hi|hey|greetings|good morning|good afternoon)\\b").matcher(text).find()) {            intentScores.merge("GREETING", 0.9, Double::sum);        }        // 告别关键词        if (Pattern.compile("\\b(bye|goodbye|see you|farewell|good night)\\b").matcher(text).find()) {            intentScores.merge("FAREWELL", 0.9, Double::sum);        }        // 问题关键词        if (Pattern.compile("\\b(what|when|where|why|how|who|which|can you|could you)\\b").matcher(text).find()) {            intentScores.merge("QUESTION", 0.6, Double::sum);        }        // 帮助请求关键词        if (Pattern.compile("\\b(help|assist|support|problem|issue|trouble)\\b").matcher(text).find()) {            intentScores.merge("REQUEST_HELP", 0.7, Double::sum);        }        // 紧急情况关键词        if (Pattern.compile("\\b(emergency|urgent|asap|immediately|help me|danger)\\b").matcher(text).find()) {            intentScores.merge("EMERGENCY", 0.8, Double::sum);        }        // 抱怨关键词        if (Pattern.compile("\\b(bad|terrible|awful|hate|dislike|angry|frustrated)\\b").matcher(text).find()) {            intentScores.merge("COMPLAINT", 0.6, Double::sum);        }        // 赞美关键词        if (Pattern.compile("\\b(good|great|excellent|awesome|love|like|wonderful)\\b").matcher(text).find()) {            intentScores.merge("COMPLIMENT", 0.6, Double::sum);        }    }    /**     * 在所有意图得分中找出最高分对应的意图作为最终识别结果     *     * @param intentScores 各意图得分记录     * @return 得分最高的意图枚举值；若无有效数据则返回 UNKNOWN     */    private Intent determinePrimaryIntent(Map<String, Double> intentScores) {        return intentScores.entrySet().stream()                .max(Map.Entry.comparingByValue())                .map(entry -> Intent.valueOf(entry.getKey()))                .orElse(Intent.UNKNOWN);    }    /**     * 计算主意图在总得分中的占比作为其置信度指标     *     * @param intentScores 所有意图得分集合     * @param primaryIntent 主导意图     * @return 表示该意图可信程度的小数形式（范围 [0, 1]）     */    private double calculateConfidence(Map<String, Double> intentScores, Intent primaryIntent) {        double primaryScore = intentScores.getOrDefault(primaryIntent.name(), 0.0);        double totalScore = intentScores.values().stream().mapToDouble(Double::doubleValue).sum();        return totalScore > 0 ? primaryScore / totalScore : 0.0;    }    /**     * 构建关于意图分析过程与结果的文字描述，用于输出调试或展示用途     *     * @param intentScores 各意图得分记录     * @return 描述前三高分意图及其具体得分的字符串     */    private String generateExplanation(Map<String, Double> intentScores) {        StringBuilder explanation = new StringBuilder("意图分析结果: ");        intentScores.entrySet().stream()                .sorted(Map.Entry.<String, Double>comparingByValue().reversed())                .limit(3)                .forEach(entry -> explanation.append(String.format("%s(%.2f) ",                        Intent.valueOf(entry.getKey()), entry.getValue())));        return explanation.toString();    }}
package IntentRecognizer;import opennlp.tools.tokenize.Tokenizer;import opennlp.tools.tokenize.TokenizerME;import opennlp.tools.tokenize.TokenizerModel;import opennlp.tools.namefind.TokenNameFinderModel;import opennlp.tools.namefind.NameFinderME;import opennlp.tools.postag.POSModel;import opennlp.tools.postag.POSTaggerME;import opennlp.tools.doccat.DoccatModel;import opennlp.tools.doccat.DocumentCategorizerME;import opennlp.tools.util.Span;import org.jetbrains.annotations.Contract;import org.jetbrains.annotations.NotNull;import java.io.*;import java.util.*;/** * 基于 OpenNLP 的意图识别器实现类。 * 提供对输入文本的意图识别功能，结合规则、词性标注、命名实体识别和分类模型进行综合判断。 * (仅支持英文) */public class IntentRecognizer_OpenNLP extends IntentRecognizer{    private Tokenizer tokenizer;    // 分词器    private POSTaggerME posTagger;  // 词性标注器    private NameFinderME nameFinder;    // 命名实体识别器    private DocumentCategorizerME intentClassifier; // 意图分类器    /**     * 构造函数，初始化 OpenNLP 模型组件。     */    public IntentRecognizer_OpenNLP() {        try {            // 初始化分词器            initializeTokenizer();            // 初始化词性标注器            initializePOSTagger();            // 初始化命名实体识别器            initializeNameFinder();            // 初始化意图分类器（如果存在训练好的模型）            initializeIntentClassifier();        } catch (Exception e) {            System.err.println("OpenNLP 模型初始化失败: " + e.getMessage());        }    }    /**     * 初始化分词器。     * 尝试加载预训练的英文分词模型，若失败则使用简单空格分词器。     *      * @throws IOException 如果读取模型文件时发生错误     */    private void initializeTokenizer() throws IOException {        InputStream modelIn = getClass().getResourceAsStream("/models/en-token.bin");        if (modelIn != null) {            TokenizerModel model = new TokenizerModel(modelIn);            this.tokenizer = new TokenizerME(model);        } else {            System.err.println("未找到分词模型，使用简单空格分词");            this.tokenizer = new SimpleTokenizer();        }    }    /**     * 初始化词性标注器。     * 加载预训练的英文词性标注模型。     *      * @throws IOException 如果读取模型文件时发生错误     */    private void initializePOSTagger() throws IOException {        InputStream modelIn = getClass().getResourceAsStream("/models/en-pos-maxent.bin");        if (modelIn != null) {            POSModel model = new POSModel(modelIn);            this.posTagger = new POSTaggerME(model);        }    }    /**     * 初始化命名实体识别器。     * 加载预训练的人名识别模型。     *      * @throws IOException 如果读取模型文件时发生错误     */    private void initializeNameFinder() throws IOException {        InputStream modelIn = getClass().getResourceAsStream("/models/en-ner-person.bin");        if (modelIn != null) {            TokenNameFinderModel model = new TokenNameFinderModel(modelIn);            this.nameFinder = new NameFinderME(model);        }    }    /**     * 初始化意图分类器。     * 加载预训练的文档分类模型用于意图识别。     *      * @throws IOException 如果读取模型文件时发生错误     */    private void initializeIntentClassifier() throws IOException {        InputStream modelIn = getClass().getResourceAsStream("/models/intent-classifier.bin");        if (modelIn != null) {            DoccatModel model = new DoccatModel(modelIn);            this.intentClassifier = new DocumentCategorizerME(model);        }    }    /**     * 对输入文本进行意图识别分析。     * 结合多种方法（规则、词性、实体、分类器）计算意图得分，并返回最高分意图及其置信度。     *      * @param text 输入的待识别文本     * @return IntentAnalysisResult 包含识别出的主要意图、置信度和解释说明的结果对象     */    @Override    public IntentAnalysisResult recognizeIntent(String text) {        Map<String, Double> intentScores = new HashMap<>();        // 分词        String[] tokens = tokenizer.tokenize(text);        // 1. 使用训练好的分类器        applyClassifierScoring(text, intentScores);        // 2. 基于词性标注的意图识别        applyPOSBasedScoring(tokens, intentScores);        // 3. 基于命名实体的意图识别        applyEntityBasedScoring(tokens, intentScores);        // 4. 基于规则的意图识别用于补充        applyRuleBasedScoring(text, tokens, intentScores);        // 确定主要意图        Intent primaryIntent = determinePrimaryIntent(intentScores);        double confidence = calculateConfidence(intentScores, primaryIntent);        return new IntentAnalysisResult(primaryIntent, confidence, generateExplanation(intentScores, tokens));    }    /**     * 应用基于关键词匹配的规则评分。     * 根据文本中是否包含特定关键词来为不同意图打分。     *      * @param text 原始输入文本（小写）     * @param tokens 分词后的字符串数组     * @param intentScores 存储各意图得分的映射表     */    private void applyRuleBasedScoring(@org.jetbrains.annotations.NotNull String text, String[] tokens, Map<String, Double> intentScores) {        String lowerText = text.toLowerCase();        // 问候意图规则        if (containsAny(lowerText, "hello", "hi", "hey", "greetings", "good morning", "good afternoon")) {            intentScores.merge("GREETING", 0.9, Double::max);        }        // 告别意图规则        if (containsAny(lowerText, "bye", "goodbye", "see you", "farewell", "good night")) {            intentScores.merge("FAREWELL", 0.9, Double::max);        }        // 问题意图规则        if (containsAny(lowerText, "what", "when", "where", "why", "how", "who", "which") ||                lowerText.contains("?")) {            intentScores.merge("QUESTION", 0.7, Double::max);        }        // 请求意图规则        if (containsAny(lowerText, "can you", "could you", "please", "would you", "help me")) {            intentScores.merge("REQUEST", 0.8, Double::max);        }        // 帮助意图规则        if (containsAny(lowerText,                "what can you",                "how can you",                "can you help",                "show me",                "capabilities",                "functions",                "services",                "features",                "commands",                "abilities")) {            intentScores.merge("HELP", 0.7, Double::max);        }        // 询问时间意图规则        if (containsAny(lowerText, "time","clock","hour","minute")) {            intentScores.merge("TIME", 0.8, Double::max);        }        // 询问天气意图规则        if (containsAny(lowerText, "weather", "temperature", "rain", "sun", "wind", "cloud")) {            intentScores.merge("WEATHER", 0.8, Double::max);        }        // 基于句子开头的规则        if (tokens.length > 0) {            String firstWord = tokens[0].toLowerCase();            if (firstWord.equals("i") || firstWord.equals("we") || firstWord.equals("my")) {                intentScores.merge("STATEMENT", 0.5, Double::sum);            }        }    }    /**     * 应用基于词性标注的评分。     * 利用词性标签统计信息为意图打分。     *      * @param tokens 分词后的字符串数组     * @param intentScores 存储各意图得分的映射表     */    private void applyPOSBasedScoring(String[] tokens, Map<String, Double> intentScores) {        if (posTagger == null) return;        String[] posTags = posTagger.tag(tokens);        // 统计词性分布        long questionWords = Arrays.stream(posTags)                .filter(tag -> tag.startsWith("W")) // WH-疑问词                .count();        long verbs = Arrays.stream(posTags)                .filter(tag -> tag.startsWith("VB"))                .count();        long nouns = Arrays.stream(posTags)                .filter(tag -> tag.startsWith("NN"))                .count();        // 基于词性分布评分        if (questionWords > 0) {            intentScores.merge("QUESTION", 0.3 * questionWords, Double::sum);        }        if (verbs > nouns && verbs > 2) {            intentScores.merge("REQUEST", 0.2, Double::sum);        }        if (nouns > verbs && nouns > 2) {            intentScores.merge("STATEMENT", 0.2, Double::sum);        }    }    /**     * 应用基于命名实体识别的评分。     * 若检测到人名等实体，则为相关意图加分。     *      * @param tokens 分词后的字符串数组     * @param intentScores 存储各意图得分的映射表     */    private void applyEntityBasedScoring(String[] tokens, Map<String, Double> intentScores) {        if (nameFinder == null) return;        try {            Span[] nameSpans = nameFinder.find(tokens);            if (nameSpans.length > 0) {                // 包含人名，可能是问候或个人信息相关                intentScores.merge("GREETING", 0.3, Double::sum);                intentScores.merge("STATEMENT", 0.2, Double::sum);            }        } catch (Exception e) {            // 实体识别失败，忽略        }    }    /**     * 应用基于分类器的评分。     * 使用预训练的文档分类模型为意图打分。     *      * @param text 原始输入文本     * @param intentScores 存储各意图得分的映射表     */    private void applyClassifierScoring(String text, Map<String, Double> intentScores) {        if (intentClassifier == null) return;        // 先对文本进行分词        String[] tokens = tokenizer.tokenize(text);        try {            double[] outcomes = intentClassifier.categorize(tokens);            int numCategories = intentClassifier.getNumberOfCategories();            String[] categories = new String[numCategories];            for (int i = 0; i < numCategories; i++) {                categories[i] = intentClassifier.getCategory(i);            }            for (int i = 0; i < outcomes.length; i++) {                if (outcomes[i] > 0.1) { // 只考虑有意义的概率                    intentScores.merge(categories[i].toUpperCase(), outcomes[i], Double::sum);                }            }        } catch (Exception e) {            // 分类器失败，忽略        }    }    /**     * 检查文本中是否包含任意一个关键词。     *      * @param text 待检查的文本     * @param keywords 关键词列表     * @return boolean 是否包含任一关键词     */    private boolean containsAny(@NotNull String text, String... keywords) {        return Arrays.stream(keywords).anyMatch(text::contains);    }    /**     * 确定得分最高的意图。     *      * @param intentScores 各意图得分映射表     * @return Intent 得分最高的意图枚举值，若无匹配则返回 UNKNOWN     */    private Intent determinePrimaryIntent(@NotNull Map<String, Double> intentScores) {        return intentScores.entrySet().stream()                .max(Map.Entry.comparingByValue())                .map(entry -> {                    try {                        return Intent.valueOf(entry.getKey());                    } catch (IllegalArgumentException e) {                        return Intent.UNKNOWN;                    }                })                .orElse(Intent.UNKNOWN);    }    /**     * 计算主要意图的置信度。     * 基于得分归一化和得分差异调整置信度。     *      * @param intentScores 各意图得分映射表     * @param primaryIntent 主要意图     * @return double 置信度值（0~1之间）     */    private double calculateConfidence(@NotNull Map<String, Double> intentScores, @NotNull Intent primaryIntent) {        double primaryScore = intentScores.getOrDefault(primaryIntent.name(), 0.0);        double totalScore = intentScores.values().stream().mapToDouble(Double::doubleValue).sum();        if (totalScore == 0) return 0.0;        // 归一化并考虑分数分布        double normalizedScore = primaryScore / totalScore;        double scoreDifference = intentScores.values().stream()                .sorted(Comparator.reverseOrder())                .limit(2)                .reduce((first, second) -> first - second)                .orElse(0.0);        return Math.min(normalizedScore + (scoreDifference * 0.1), 1.0);    }    /**     * 生成意图识别结果的解释说明。     * 显示前三个得分最高的意图及其得分。     *      * @param intentScores 各意图得分映射表     * @param tokens 分词后的字符串数组     * @return String 解释说明字符串     */    private @NotNull String generateExplanation(@NotNull Map<String, Double> intentScores, String @NotNull [] tokens) {        StringBuilder explanation = new StringBuilder("分词[");        explanation.append(tokens.length).append("个], ");        intentScores.entrySet().stream()                .sorted(Map.Entry.<String, Double>comparingByValue().reversed())                .limit(3)                .forEach(entry -> {                    try {                        Intent intent = Intent.valueOf(entry.getKey());                        explanation.append(String.format("%s(%.2f) ", intent, entry.getValue()));                    } catch (IllegalArgumentException e) {                        // 忽略未知意图                    }                });        return explanation.toString();    }    /**     * 简单的空格分词器（备用）     * 在OpenNLP预设的分词器出现问题时替代     */    private static class SimpleTokenizer implements Tokenizer {        /**         * 使用空格分割字符串为 token。         *          * @param s 输入字符串         * @return String[] 分割后的 token 数组         */        @Contract(pure = true)        @Override        public String @NotNull [] tokenize(@NotNull String s) {            return s.split("\\s+");        }        /**         * 获取每个 token 在原字符串中的位置信息。         *          * @param s 输入字符串         * @return Span[] 每个 token 的起止位置         */        @Override        public Span @NotNull [] tokenizePos(String s) {            String[] tokens = tokenize(s);            Span[] spans = new Span[tokens.length];            int start = 0;            for (int i = 0; i < tokens.length; i++) {                spans[i] = new Span(start, start + tokens[i].length());                start += tokens[i].length() + 1; // +1 for space            }            return spans;        }    }}
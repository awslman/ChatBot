package IntentRecognizer;import java.io.*;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.concurrent.*;import java.nio.charset.StandardCharsets;import Data.EntitiesNLTK;import Data.IntentNLTK;import Data.SentimentNLTK;import com.google.gson.Gson;import com.google.gson.JsonObject;import com.google.gson.JsonParser;/** * 本地NLTK包装器类 * 该类提供了Java与Python NLTK库之间的接口，通过执行Python脚本来实现自然语言处理功能。 * 支持两种模式：每次调用创建新进程和持久化进程（复用同一进程提高性能）。 */public class LocalNLTKWrapper {    private final String pythonScriptPath;    private final String pythonExecutable;    private final Gson gson;    private final ExecutorService executor;    // 缓存Python进程以提高性能    private Process pythonProcess;    private BufferedWriter processInput;    private BufferedReader processOutput;    private BufferedReader processError;    /**     * 默认构造函数     * 使用默认的Python可执行文件路径和脚本路径初始化     */    public LocalNLTKWrapper() {        this("src/main/resources/NLTK_nlp_processor.exe", "src/main/python/NLTK_nlp_processor.py");    }    /**     * 带参数的构造函数     *     * @param pythonExecutable Python可执行文件路径     * @param scriptPath Python脚本路径     */    public LocalNLTKWrapper(String pythonExecutable, String scriptPath) {        this.pythonExecutable = pythonExecutable;        this.pythonScriptPath = scriptPath;        this.gson = new Gson();        this.executor = Executors.newCachedThreadPool();        // 初始化时启动Python进程        initializePersistentProcess();    }    /**     * 进程调用方法1：每次调用启动新进程     * 简单可靠，避免进程状态问题     *     * @param method 要调用的Python方法名     * @param text 要处理的文本     * @return JsonObject 处理结果，包含状态和数据     */    public JsonObject callNLTK(String method, String text) {        try {            // 直接调用打包好的可执行文件            ProcessBuilder pb = new ProcessBuilder(                    pythonExecutable, method, text            );            // 设置工作目录            pb.directory(new File("."));            // 启动进程            Process process = pb.start();            // 设置超时            boolean finished = process.waitFor(30, TimeUnit.SECONDS);            if (!finished) {                process.destroyForcibly();                return createErrorResult("Process timeout");            }            // 读取输出            String output = readProcessOutput(process);            // 检查退出码            if (process.exitValue() != 0) {                String error = readProcessError(process);                return createErrorResult("Python process error: " + error);            }            // 解析JSON结果            return JsonParser.parseString(output).getAsJsonObject();        } catch (IOException | InterruptedException e) {            return createErrorResult("Java process error: " + e.getMessage());        }    }    /**     * 进程调用方法2：持久化进程     * 初始化持久化的Python进程     */    private void initializePersistentProcess() {        try {            // 检查是否是exe文件路径来决定参数            List<String> command = new ArrayList<>();            command.add(pythonExecutable);                        // 只有在不是exe文件时才添加脚本路径            if (!pythonExecutable.endsWith(".exe") && !pythonExecutable.endsWith("NLTK_nlp_processor")) {                command.add(pythonScriptPath);            }                        ProcessBuilder pb = new ProcessBuilder(command);            pb.directory(new File("."));            pythonProcess = pb.start();            processInput = new BufferedWriter(                    new OutputStreamWriter(pythonProcess.getOutputStream(), StandardCharsets.UTF_8));            processOutput = new BufferedReader(                    new InputStreamReader(pythonProcess.getInputStream(), StandardCharsets.UTF_8));            processError = new BufferedReader(                    new InputStreamReader(pythonProcess.getErrorStream(), StandardCharsets.UTF_8));            // 启动错误流读取线程            executor.submit(this::readErrorStream);        } catch (IOException e) {            System.err.println("Failed to initialize persistent Python process: " + e.getMessage());        }    }    /**     * 使用持久化进程调用NLTK功能     *     * @param method 要调用的Python方法名     * @param text 要处理的文本     * @return JsonObject 处理结果，包含状态和数据     */    public JsonObject callNLTKPersistent(String method, String text) {        if (pythonProcess == null || !pythonProcess.isAlive()) {            initializePersistentProcess();        }        try {            // 发送请求            String request = method + "|||" + text.replace("|||", " ") + "\n";            processInput.write(request);            processInput.flush();            // 读取响应（带超时）            Future<String> future = executor.submit(() -> processOutput.readLine());            String response = future.get(10, TimeUnit.SECONDS);            return JsonParser.parseString(response).getAsJsonObject();        } catch (Exception e) {            return createErrorResult("Persistent process error: " + e.getMessage());        }    }    /**     * 读取进程的标准输出     *     * @param process 要读取的进程     * @return String 进程的输出内容     * @throws IOException IO异常     */    private String readProcessOutput(Process process) throws IOException {        StringBuilder output = new StringBuilder();        try (BufferedReader reader = new BufferedReader(                new InputStreamReader(process.getInputStream()))) {            String line;            while ((line = reader.readLine()) != null) {                output.append(line);            }        }        return output.toString();    }    /**     * 读取进程的错误输出     *     * @param process 要读取的进程     * @return String 进程的错误输出内容     * @throws IOException IO异常     */    private String readProcessError(Process process) throws IOException {        StringBuilder error = new StringBuilder();        try (BufferedReader reader = new BufferedReader(                new InputStreamReader(process.getErrorStream()))) {            String line;            while ((line = reader.readLine()) != null) {                error.append(line).append(" ");            }        }        return error.toString();    }    /**     * 读取Python进程的错误流     * 在单独的线程中运行以避免阻塞     */    private void readErrorStream() {        try {            String line;            while ((line = processError.readLine()) != null) {                System.err.println("Python: " + line);            }        } catch (IOException e) {            System.err.println("Error reading Python error stream: " + e.getMessage());        }    }    /**     * 创建错误结果对象     *     * @param errorMessage 错误消息     * @return JsonObject 包含错误信息的JSON对象     */    private JsonObject createErrorResult(String errorMessage) {        JsonObject error = new JsonObject();        error.addProperty("status", "error");        error.addProperty("error", errorMessage);        return error;    }    /**     * 关闭资源     * 销毁Python进程并关闭线程池     */    public void close() {        if (pythonProcess != null && pythonProcess.isAlive()) {            pythonProcess.destroy();        }        executor.shutdown();    }    // 便捷方法    /**     * 文本分词     *     * @param text 要分词的文本     * @return JsonObject 分词结果     */    public JsonObject tokenize(String text) {        return callNLTKPersistent("tokenize", text);    }    /**     * 词性标注     *     * @param text 要进行词性标注的文本     * @return JsonObject 词性标注结果     */    public JsonObject posTag(String text) {        return callNLTKPersistent("pos_tag", text);    }    /**     * 情感分析     *     * @param text 要进行情感分析的文本     * @return JsonObject 情感分析结果     */    public SentimentNLTK analyzeSentiment(String text) {        JsonObject result = callNLTKPersistent("sentiment", text);        if (result.has("status") && result.get("status").getAsString().equals("error")) {            throw new RuntimeException("Sentiment analysis error: " + result);        }        return gson.fromJson(callNLTKPersistent("sentiment", text), SentimentNLTK.class);    }    /**     * 意图识别     *     * @param text 要进行意图识别的文本     * @return IntentNLTK 意图识别结果     */    public IntentNLTK recognizeIntent(String text) {        JsonObject result = callNLTKPersistent("intent", text);        if (result.has("status") && result.get("status").getAsString().equals("error")) {            String errorMessage = result.toString();            // 特别处理超时错误            if (errorMessage.contains("Process timeout")) {                System.err.println("警告: NLTK处理超时，使用默认意图处理");                IntentNLTK defaultIntent = new IntentNLTK();                defaultIntent.setIntents(Collections.singletonList("unknown"));                defaultIntent.setConfidence(0.0);                return defaultIntent;            }            throw new RuntimeException("Intent recognition error: " + errorMessage);        }        return gson.fromJson(result, IntentNLTK.class);    }    /**     * 实体识别     *     * @param text 要进行实体识别的文本     * @return EntitiesNLTK 实体识别结果     */    public EntitiesNLTK extractEntities(String text) {        JsonObject result = callNLTKPersistent("ner", text);        if (result.has("status") && result.get("status").getAsString().equals("error")) {            throw new RuntimeException("Entity extraction error: " + result);        }        return gson.fromJson(callNLTKPersistent("ner", text), EntitiesNLTK.class);    }}
package SimpleResponseGenerator;import java.util.*;/** * 中文处理工具类 * 提供中文文本处理的相关功能，包括分词、标点符号处理和字符判断等 */public class ChineseTextProcessor {    /**     * 基于词典的最大正向匹配分词     * 从左到右扫描文本，每次取最长可能的词与词典匹配，找到则切分，否则逐字递减匹配     *      * @param text 待分词的中文文本     * @param dictionary 词典集合，包含所有可能的词语     * @return 分词结果列表     */    public static List<String> forwardMaxMatch(String text, Set<String> dictionary) {        List<String> result = new ArrayList<>();        int maxWordLength = getMaxWordLength(dictionary);        int position = 0;        int textLength = text.length();        while (position < textLength) {            int len = Math.min(maxWordLength, textLength - position);            String word = null;            // 从最长可能词开始匹配            for (; len > 0; len--) {                String candidate = text.substring(position, position + len);                if (dictionary.contains(candidate)) {                    word = candidate;                    break;                }            }            if (word == null) {                // 单字成词                word = text.substring(position, position + 1);                len = 1;            }            result.add(word);            position += len;        }        return result;    }    /**     * 简单按字符分割（用于基础功能）     * 将文本按字符逐个分割，每个字符作为一个独立元素     *      * @param text 待分割的文本     * @return 字符列表     */    public static List<String> characterSegmentation(String text) {        List<String> characters = new ArrayList<>();        for (int i = 0; i < text.length(); i++) {            characters.add(String.valueOf(text.charAt(i)));        }        return characters;    }    /**     * 混合分词（字符+常见词）     * 优先匹配2-4字的常见词语，无法匹配时按单字分割     *      * @param text 待分词的文本     * @param commonWords 常见词语集合     * @return 分词结果列表     */    public static List<String> hybridSegmentation(String text, Set<String> commonWords) {        List<String> result = new ArrayList<>();        int i = 0;        while (i < text.length()) {            boolean found = false;            // 尝试匹配2-4字词语            for (int len = 4; len >= 2; len--) {                if (i + len <= text.length()) {                    String candidate = text.substring(i, i + len);                    if (commonWords.contains(candidate)) {                        result.add(candidate);                        i += len;                        found = true;                        break;                    }                }            }            if (!found) {                // 单字分割                result.add(text.substring(i, i + 1));                i++;            }        }        return result;    }    /**     * 获取词典中最长词语的长度     *      * @param dictionary 词典集合     * @return 最长词语的字符数     */    private static int getMaxWordLength(Set<String> dictionary) {        return dictionary.stream()                .mapToInt(String::length)                .max()                .orElse(1);    }    /**     * 中文标点符号处理     * 移除文本中的中文标点符号     *      * @param text 待处理的文本     * @return 移除标点符号后的文本     */    public static String removeChinesePunctuation(String text) {        return text.replaceAll("[\\pP\\p{Punct}]", "");    }    /**     * 判断字符是否为中文     * 通过Unicode区块判断字符是否属于中文字符范围     *      * @param c 待判断的字符     * @return 如果是中文字符返回true，否则返回false     */    public static boolean isChineseCharacter(char c) {        Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);        return ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS                || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS                || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A;    }}
package Bots;import Data.*;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.Scanner;/** * 简易聊天机器人基类 * 提供聊天机器人的基础功能，包括对话历史管理、上下文维护、关键词匹配等 * 这是一个抽象类，具体的聊天机器人实现需要继承此类并实现processInput方法 */public abstract class SimpleChatBot {    /**     * 对话历史记录管理器     */    protected final DialogueHistory history;        /**     * 对话上下文管理器，用于维护对话的上下文信息     */    protected final DialogueContext context;        /**     * 关键词前缀树，用于快速匹配关键词命令     */    protected final KeywordTrieTree keywordTrieTree;    /**     * 构造函数，初始化聊天机器人的基础组件     * 包括对话历史、上下文管理和关键词匹配树     */    public SimpleChatBot() {        this.history = new DialogueHistory();        this.context = new DialogueContext(5); // 保持最近5条对话作为上下文        this.keywordTrieTree = new KeywordTrieTree();        this.initializeKeywords();    }    /**     * 清屏方法     * 尝试使用系统命令清屏，如果失败则使用ANSI转义序列     */    public static void clearScreen() {        try {            new ProcessBuilder("cmd", "/c", "cls").inheritIO().start().waitFor();        } catch (Exception e) {            // 如果cls命令失败，回退到ANSI转义序列            System.out.print("\033[2J\033[H");            System.out.flush();        }    }    /**     * 初始化关键词和对应的默认回复     * 预设了一些常用的关键词及其回复内容     */    private void initializeKeywords() {        // 初始化关键词和回复        this.keywordTrieTree.insert("name", "我的名字是ChatBot，你的名字是?");        this.keywordTrieTree.insert("age", "差不多一个月吧。");        this.keywordTrieTree.insert("sorry", "没关系的。");        this.keywordTrieTree.insert("time", "现在的时间是：" + new Date());    }    /**     * 抽象方法，处理用户输入     * 具体的聊天机器人实现需要重写此方法来定义如何处理用户输入     *      * @param userInput 用户输入的文本内容     */    public abstract void processInput(String userInput);    /**     * 导航浏览历史记录     * 允许用户在历史对话记录中前后浏览     *      * @param scanner 输入扫描器，用于读取用户的导航命令     */    protected void navigateHistory(Scanner scanner) {        history.resetToLatest();        String command;        do {            clearScreen();            System.out.println("=== 历史回溯模式 ===");            System.out.println("使用 'b' 向后查看，'f' 向前查看，'l' 回到最新，'q' 退出");            // 显示当前查看的消息及其上下文            displayCurrentWithContext();            System.out.print("导航命令 (b/f/l/q): ");            command = scanner.nextLine().trim().toLowerCase();            switch (command) {                case "f":                    Message prev = history.moveBackward();                    if (prev == null) {                        System.out.println("已经到达历史开头");                        pause(1000);                    }                    break;                case "b":                    Message next = history.moveForward();                    if (next == null) {                        System.out.println("已经到达历史末尾");                        pause(1000);                    }                    break;                case "l":                    history.resetToLatest();                    System.out.println("已回到最新对话");                    pause(1000);                    break;                case "q":                    System.out.println("退出历史回溯模式");                    break;                default:                    System.out.println("未知命令");                    pause(1000);            }        } while (!command.equals("q"));    }    /**     * 显示当前消息及其上下文     * 展示当前查看的历史消息以及其前后的上下文消息     */    private void displayCurrentWithContext() {        Message current = history.getCurrent();        if (current == null) {            System.out.println("暂无历史记录");            return;        }        // 显示前2条消息作为上下文        List<Message> context = getContextAroundCurrent(2);        for (Message msg : context) {            String marker = msg.equals(current) ? ">>> " : "    ";            System.out.println(marker + msg);        }        System.out.println("------------------------");    }    /**     * 获取当前消息周围的上下文消息     *      * @param contextSize 上下文大小，表示前后各取多少条消息     * @return 包含当前消息及其上下文的消息列表     */    private List<Message> getContextAroundCurrent(int contextSize) {        List<Message> context = new ArrayList<>();        // 向前获取上下文        DialogueNode node = getCurrentNode();        for (int i = 0; i < contextSize && node.prev != null; i++) {            node = node.prev;        }        // 向后显示2*contextSize+1条消息        for (int i = 0; i < 2 * contextSize + 1 && node != null; i++) {            context.add(node.message);            node = node.next;        }        return context;    }    /**     * 获取当前节点     * 使用反射获取对话历史中的当前节点     *      * @return 当前对话节点，如果获取失败则返回null     */    private DialogueNode getCurrentNode() {        try {            java.lang.reflect.Field currentField = history.getClass().getDeclaredField("current");            currentField.setAccessible(true);            return (DialogueNode) currentField.get(history);        } catch (Exception e) {            System.err.println("无法访问当前节点: " + e.getMessage());            return null;        }    }    /**     * 暂停方法     * 使当前线程暂停指定的毫秒数     *      * @param milliseconds 暂停的毫秒数     */    public static void pause(long milliseconds) {        try {            Thread.sleep(milliseconds);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }    /**     * 运行聊天机器人主循环     * 处理用户输入、显示对话历史、响应用户命令     */    public void run() {        Scanner scanner = new Scanner(System.in);        String input;        do {            // 清屏并显示最新10条对话            clearAndDisplayRecentMessages(10);            System.out.print("You: ");            input = scanner.nextLine().trim();            clearScreen();            Message userMessage,botMessage;            String response;            String userInput = input.toLowerCase();            userMessage = new Message("User", userInput);            history.addMessage(userMessage);            context.addToContext(userMessage);            switch (userInput) {                case "history":                    response = "已为你呈现对话历史记录";                    botMessage = new Message("bot",response);                    history.addMessage(botMessage);                    context.addToContext(botMessage);                    history.printHistory();                    System.out.println("按回车继续...");                    waitForEnter();                    break;                case "navigate":                    navigateHistory(scanner);                    break;                case "q":                case "quit":                    break;                default:                    processInput(userInput);            }        } while (!input.equalsIgnoreCase("quit")&&!input.equalsIgnoreCase("q"));    }    /**     * 等待用户按回车键，用于暂停显示     */    void waitForEnter() {        try {            // 清空缓冲区中的换行符            do {                System.in.read();            } while (System.in.available() > 0);        } catch (Exception e) {            // 忽略异常        }    }    /**     * 清屏并显示最近的对话消息     *      * @param numberOfMessages 要显示的最近消息数量     */    protected void clearAndDisplayRecentMessages(int numberOfMessages) {        clearScreen();        System.out.println("=== 简易聊天机器人 ===");        System.out.println("命令: 'history' - 查看历史, 'navigate' - 历史回溯, 'quit'/'q' - 退出");        System.out.println("==================================================================");        List<Message> recentMessages = getRecentMessages(numberOfMessages);        if (recentMessages.isEmpty()) {            System.out.println("暂无对话记录");        } else {            for (Message message : recentMessages) {                System.out.println(message.toString());            }        }        System.out.println("==================================================================");    }    /**     * 获取最近的N条消息     * 从对话历史中获取最近的指定数量的消息     *      * @param numberOfMessages 要获取的消息数量     * @return 最近的消息列表     */    private List<Message> getRecentMessages(int numberOfMessages) {        List<Message> recentMessages = new ArrayList<>();        // 从双向链表的尾部开始向前遍历        DialogueNode current = history.getTail();        int count = 0;        while (current != null && count < numberOfMessages) {            recentMessages.add(0, current.message); // 添加到开头，保持时间顺序            current = current.prev;            count++;        }        return recentMessages;    }}
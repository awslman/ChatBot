package Bots;import Data.IntentNLTK;import Data.Message;import Data.SentimentNLTK;import IntentRecognizer.IntentRecognizer_NLTK;import IntentRecognizer.LocalNLTKWrapper;import SimpleResponseGenerator.ChineseResponseGenerator;import SimpleResponseGenerator.SimpleChineseSegmenter;/** * 基于NLTK的聊天机器人 * 使用Python的NLTK库进行自然语言处理，包括意图识别和情感分析 * 能够根据用户输入的意图和情感生成更加个性化的回复 */public class SimpleChatBotUsedNLTK extends SimpleChatBot {    /**     * 中文回复生成器，用于生成基础回复内容     */    private final ChineseResponseGenerator responseGenerator;    /**     * 构造函数，初始化NLTK聊天机器人     * 初始化本地NLTK包装器和中文回复生成器     */    public SimpleChatBotUsedNLTK() {        new LocalNLTKWrapper();        this.responseGenerator = new ChineseResponseGenerator(new SimpleChineseSegmenter());    }    /**     * 生成增强型回复     * 根据NLTK分析得到的意图和情感信息，生成更加个性化和准确的回复     *      * @param userInput 用户输入内容     * @param intent NLTK意图分析结果     * @param sentiment NLTK情感分析结果     * @return 生成的回复字符串     */    private String generateEnhancedResponse(String userInput, IntentNLTK intent,                                            SentimentNLTK sentiment) {        if (!intent.getStatus().equals("success")) {            return responseGenerator.generateResponse(userInput);        }        String primaryIntent = intent.getIntents().get(0);        double confidence = intent.getConfidence();        String sentimentType = sentiment.getSentiment();        // 基于NLTK分析生成更精准的回复        switch (primaryIntent) {            case "greeting":                return getPersonalizedGreeting(sentimentType);            case "question":                return getQuestionResponse(confidence);            case "farewell":                return getFarewellResponse(sentimentType);            default:                return responseGenerator.generateResponse(userInput);        }    }    /**     * 根据情感类型生成个性化问候语     *      * @param sentiment 情感类型(positive/negative/neutral)     * @return 个性化的问候语     */    private String getPersonalizedGreeting(String sentiment) {        switch (sentiment) {            case "positive":                return "你好！看到你这么积极真让人高兴！";            case "negative":                return "你好！希望你今天能变得开心一些！";            default:                return "你好！有什么我可以帮你的吗？";        }    }    /**     * 根据问题置信度生成问题回复     *      * @param confidence 意图识别的置信度     * @return 针对问题的回复     */    private String getQuestionResponse(double confidence) {        if (confidence > 0.8) {            return "这是一个很好的问题！让我来详细为你解答...";        } else {            return "我不太确定你的问题，能再详细说明一下吗？";        }    }    /**     * 根据情感类型生成告别语     *      * @param sentiment 情感类型(positive/negative/neutral)     * @return 个性化的告别语     */    private String getFarewellResponse(String sentiment) {        switch (sentiment) {            case "positive":                return "再见！很高兴和你聊天，期待下次再见！";            case "negative":                return "再见！希望你的心情能好起来！";            default:                return "再见！祝你一切顺利！";        }    }    /**     * 处理用户输入     * 首先尝试关键词匹配，如果未匹配到则使用NLTK进行深度分析并生成回复     *      * @param userInput 用户输入的文本内容     */    @Override    public void processInput(String userInput) {        String response;        IntentRecognizer_NLTK.IntentAnalysisResult intentAnalysisResult = null;        // 尝试关键词匹配命令        String keywordResponse = keywordTrieTree.search(userInput);        if (keywordResponse != null) {            response = keywordResponse;        } else {            // 使用NLTK进行深度分析            IntentRecognizer_NLTK intentRecognizer = new IntentRecognizer_NLTK();            intentAnalysisResult = intentRecognizer.recognizeIntent(userInput);            // 基于NLTK分析生成智能回复            response = generateEnhancedResponse(userInput, intentAnalysisResult.getIntent_NLTK(), intentAnalysisResult.getSentiment());        }        Message botMessage = new Message("Bots", response, intentAnalysisResult);        history.addMessage(botMessage);        context.addToContext(botMessage);    }    /**     * 运行NLTK聊天机器人     * 调用父类的运行方法启动主循环     */    @Override    public void run() {        super.run();    }}
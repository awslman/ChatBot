package Bots;import java.util.HashMap;import java.util.Map;import java.util.Scanner;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import LLM.ModelHandler;import LLM.ResponseGenerator.GenericModelHandler;import io.reactivex.Flowable;import io.reactivex.disposables.Disposable;/** * 基于大语言模型(LLM)的聊天机器人 * 该类实现了使用大语言模型生成回复的功能，支持多种不同的LLM模型 * 并提供了流式响应输出以提升用户体验 */public class SimpleChatBotUsedLLM extends SimpleChatBot{    /**     * 当前选择的模型ID     */    private String modelId;        /**     * 模型处理器映射表     * 用于存储模型ID与对应处理器的映射关系，避免重复创建处理器实例     */    private final Map<String, ModelHandler> MODEL_HANDLERS = new HashMap<>();        /**     * 模型名称映射表     * 存储模型ID与模型名称的映射关系，便于用户选择和显示     */    private final Map<String, String> MODEL_NAMES = new HashMap<>();        /**     * 构造函数，初始化LLM聊天机器人     * 调用父类构造函数并初始化可用的模型列表     */    public SimpleChatBotUsedLLM() {        super();        initializeModels();    }        /**     * 初始化可用的大语言模型列表     * 设置模型ID与模型名称的映射关系     */    private void initializeModels() {        // 初始化模型名称映射        MODEL_NAMES.put("1", "deepseek-r1-0528");        MODEL_NAMES.put("2", "deepseek-v3.1");        MODEL_NAMES.put("3", "Moonshot-Kimi-K2-Instruct");        MODEL_NAMES.put("4", "qwen3-max");        MODEL_NAMES.put("5", "qwen-plus");        // 添加新模型时只需在此处添加映射关系        // 不再预先初始化所有模型处理器，只在需要时创建    }    /**     * 获取指定模型ID的模型处理器     * 如果处理器不存在则创建新的实例并缓存     *      * @param modelId 模型ID     * @return 对应的模型处理器实例     */    private ModelHandler getModelHandler(String modelId) {        // 检查是否已经有该模型的处理器        if (!MODEL_HANDLERS.containsKey(modelId)) {            // 如果没有，则创建并缓存            String modelName = MODEL_NAMES.get(modelId);            if (modelName != null) {                MODEL_HANDLERS.put(modelId, new GenericModelHandler(modelName));            }        }        return MODEL_HANDLERS.get(modelId);    }    /**     * 处理用户输入并生成回复     * 首先尝试关键词匹配，如果未匹配到则调用大语言模型生成回复     *      * @param userInput 用户输入的文本内容     */    @Override    public void processInput(String userInput) {        // 1. 首先尝试关键词匹配        String keywordResponse = keywordTrieTree.search(userInput);        if (keywordResponse != null) {            System.out.println("Bot: " + keywordResponse);        } else {            // 2.调用智能体应用api生成回复            try{                // 检查模型是否存在                    ModelHandler handler = getModelHandler(modelId);                    System.out.print("Bot: ");                    // 使用StringBuilder收集流式响应内容                    StringBuilder responseBuilder = new StringBuilder();                                        // 使用CompletableFuture处理流式响应                    CompletableFuture<Void> future = new CompletableFuture<>();                                        try {                        Flowable<String> stream = handler.generateResponseStream(userInput);                        Disposable disposable = stream.doOnError(future::completeExceptionally)                                .doOnComplete(() -> {                                    future.complete(null);                                    System.out.println(); // 换行                                })                                .subscribe(chunk -> {                                    System.out.print(chunk);                                    responseBuilder.append(chunk);                                });                                                // 等待流完成                        future.get();                        // 释放资源                        disposable.dispose();                        String fullResponse = responseBuilder.toString();                        handler.addBotMessage(fullResponse);                    } catch (ExecutionException e) {                        throw e.getCause();                    }            } catch (Throwable e) {                if (e.getMessage() != null && e.getMessage().contains("Model not exist")) {                    System.err.println("Bot: 模型不存在，请检查模型名称是否正确或是否有权限访问该模型");                } else {                    System.err.println("Bot: 调用模型时发生错误: " + e.getMessage());                }            }        }    }    /**     * 运行LLM聊天机器人主循环     * 提供模型选择界面，并处理用户与模型的交互     */    @Override    public void run() {        Scanner scanner = new Scanner(System.in);        String input;        do {            clearScreen();            System.out.println("=== 简易聊天机器人 ===");            System.out.println("支持的模型:");            MODEL_NAMES.forEach((id, name) -> System.out.println("  " + id + " - " + name));            System.out.println("'quit'/'q' - 退出");            System.out.println("==================================================================");            System.out.print("请选择模型(" + String.join("/", MODEL_NAMES.keySet()) + "/quit): ");            this.modelId = scanner.nextLine().trim();            if (!modelId.equals("quit")&&!modelId.equals("q")) {                if(MODEL_NAMES.containsKey(modelId)) {                    clearScreen();                    System.out.println("=== 简易聊天机器人 ===");                    System.out.println("正在使用模型: " + MODEL_NAMES.getOrDefault(modelId, modelId));                    do {                        System.out.print("You: ");                        input = scanner.nextLine().trim();                        String userInput = input.toLowerCase();                        if (userInput.equals("q") || userInput.equals("quit")) {                            break;                        } else {                            processInput(userInput);                        }                    } while (!input.equalsIgnoreCase("quit") && !input.equalsIgnoreCase("q"));                }else {                    System.out.println("未知输入，请输入正确的模型编号");                }            }        } while (!modelId.equals("quit")&&!modelId.equals("q"));    }}